此为学习文档，用来记录学习的过程和dedbug的过程

阶段0：
学习如何上传本地代码到github仓库
搭建基本的虚拟机环境


阶段1：
了解使用argc，argv处理字符串，了解如何正确使用：  argc记录字符串个数，argv储存字符串
--help实现 只有自己定义的参数可以被匹配

了解fopen（），和fgets（）函数的作用  学习FILE的定义方式
读取后正确处理空格，#，打印到minimake-cleared.mk
关闭打开的文件 fclose（）

预处理和静态语法检查： preprocess（）和syntax-check（）函数的构建
学习make语言的基本语法要求--目标，依赖，命令行的基本写法；知道如何用-o，-c建立依赖关系
tap 制表符非常重要  不能用空格代替
定义目标的规则  （） ：（）
学习定义伪目标all和close，知道如何处理伪目标定义和函数名字冲突的问题

阶段2： rule-parse（）
规则解析：更加明确目标、依赖、命令三者的关系
step1：能够解析字符串，通过目标，依赖，命令行三者清晰的区别设定判定函数，如：：前，制表符，：后。
   用了一个中间变量存储解析的目标依赖和命令，用于后面验证是否正确。（此时没有为后续依赖图的构建直接建立结构体）
   疯狂debug：取消了解析构成minimake基本框架的部分，只判断指定目标函数部分
             设置了print（）函数用于打印已经解析的规则，更好的判断预期应该被解析的字符串是否被正确的解析。在判断正确解析后删除了print函数
             设置了print（）函数用于打印已经被验证正确解析的部分。同样验证完成后删去。
             此处仍要验证只是因为预处理过程只是将注释和空格回车去除，保留了可能得语法错误，此处再次检查更加严谨
step2：能够只解析指定目标的目标依赖命令，不需要全部运行
step3：在此建立结构体，用于构建一个按照图想法的结构，储存被解析的字符串，在后续构建依赖图的时候可以直接调用，不需要再次解析，简化了程序运行的步骤
       此处只涉及了存入，因为为后续调用，设置了全局变量。（学习（复习）了如何正确的构建图）
step4：优化了一些逻辑结构，通过设置返回值在main函数里实现判定，如果不通过规则解析则直接退出minimake的运行，优化了程序结构


阶段3：map（）、line（）、timecheck（）
step1：构建map（）
       基于之前已经生成的图，就无需再解析，只需要检查是否存在即可。同时为了保证逻辑严谨，还是为出现没有对应的情况构建新的节点。
       最后根据逻辑设计一个简单的入度计算函数，保留对应的入度。
       设计print函数用于在main函数中根据指令打印对应的图
       优化：只生成对应目标的额依赖图

step2： 实现line（）
        拓扑排序在依赖图的基础上可以比较简单的实现，此处去学习了DAG图和Kahn算法，再使用队列的形式打印排序
        打印逻辑根据算法容易理解
        优化：只生成对应目标的依赖图的排序

step3： 实现timecheck（）
        了解学习<sys/stat.h>库函数，了解时间戳的含义，了解time-t函数的使用方法
        优化：只对对应目标的时间戳检查

阶段4：my-system（）
      学习system（）接口的功能，设计其的目的
      学习子程序，父程序的定义标准

阶段5：variables（）
      了解环境变量表是什么，通过集成环境变量表，减少了对变量储存后的删除步骤
      此处重新定义了解析函数，避免前面的解析函数设置一些条件使得其如果在此被调用不能正确的实现预期功能
      最后设立了一个print（）用来表示是否已经成功执行了变量

阶段6：优化算法
      在各种函数里面设置了全局变量，用于在minimake --help的时候给出指令提示，使得minimake实现这些功能的时候是由指令控制，减少了不必要的程序运行
      


（中间的痛苦debug就不记录了）